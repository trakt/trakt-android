<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/di/MoviesModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/di/MoviesModule.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.movies.di&#10;&#10;import org.koin.core.module.dsl.viewModel&#10;import org.koin.core.qualifier.named&#10;import org.koin.dsl.module&#10;import org.openapitools.client.apis.MoviesApi&#10;import org.openapitools.client.apis.RecommendationsApi&#10;import tv.trakt.trakt.common.Config.API_BASE_URL&#10;import tv.trakt.trakt.core.movies.MoviesViewModel&#10;import tv.trakt.trakt.core.movies.data.local.AnticipatedMoviesLocalDataSource&#10;import tv.trakt.trakt.core.movies.data.local.HotMoviesLocalDataSource&#10;import tv.trakt.trakt.core.movies.data.local.PopularMoviesLocalDataSource&#10;import tv.trakt.trakt.core.movies.data.local.storage.AnticipatedMoviesStorage&#10;import tv.trakt.trakt.core.movies.data.local.storage.HotMoviesStorage&#10;import tv.trakt.trakt.core.movies.data.local.storage.PopularMoviesStorage&#10;import tv.trakt.trakt.core.movies.data.remote.MoviesApiClient&#10;import tv.trakt.trakt.core.movies.data.remote.MoviesRemoteDataSource&#10;import tv.trakt.trakt.core.movies.sections.anticipated.MoviesAnticipatedViewModel&#10;import tv.trakt.trakt.core.movies.sections.anticipated.usecase.GetAnticipatedMoviesUseCase&#10;import tv.trakt.trakt.core.movies.sections.hot.MoviesHotViewModel&#10;import tv.trakt.trakt.core.movies.sections.hot.usecase.GetHotMoviesUseCase&#10;&#10;internal val moviesDataModule = module {&#10;&#10;    single&lt;MoviesRemoteDataSource&gt; {&#10;        MoviesApiClient(&#10;            moviesApi = MoviesApi(&#10;                baseUrl = API_BASE_URL,&#10;                httpClientEngine = get(),&#10;                httpClientConfig = get(named(&quot;clientConfig&quot;)),&#10;            ),&#10;            recommendationsApi = RecommendationsApi(&#10;                baseUrl = API_BASE_URL,&#10;                httpClientEngine = get(),&#10;                httpClientConfig = get(named(&quot;authorizedClientConfig&quot;)),&#10;            ),&#10;        )&#10;    }&#10;}&#10;&#10;internal val moviesModule = module {&#10;    factory {&#10;        GetTrendingMoviesUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetHotMoviesUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetPopularMoviesUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetAnticipatedMoviesUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetRecommendedMoviesUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        MoviesViewModel(&#10;            sessionManager = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        MoviesTrendingViewModel(&#10;            getTrendingUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        MoviesHotViewModel(&#10;            getHotUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        MoviesAnticipatedViewModel(&#10;            getAnticipatedUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        MoviesRecommendedViewModel(&#10;            getRecommendedUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        MoviesPopularViewModel(&#10;            getPopularUseCase = get(),&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.di&#10;&#10;import org.koin.core.module.dsl.viewModel&#10;import org.koin.core.qualifier.named&#10;import org.koin.dsl.module&#10;import org.openapitools.client.apis.MoviesApi&#10;import org.openapitools.client.apis.RecommendationsApi&#10;import tv.trakt.trakt.common.Config.API_BASE_URL&#10;import tv.trakt.trakt.core.movies.MoviesViewModel&#10;import tv.trakt.trakt.core.movies.sections.anticipated.MoviesAnticipatedViewModel&#10;import tv.trakt.trakt.core.movies.sections.anticipated.data.local.AnticipatedMoviesLocalDataSource&#10;import tv.trakt.trakt.core.movies.sections.anticipated.data.local.AnticipatedMoviesStorage&#10;import tv.trakt.trakt.core.movies.sections.anticipated.usecase.GetAnticipatedMoviesUseCase&#10;import tv.trakt.trakt.core.movies.sections.hot.MoviesHotViewModel&#10;import tv.trakt.trakt.core.movies.sections.hot.data.local.HotMoviesLocalDataSource&#10;import tv.trakt.trakt.core.movies.sections.hot.data.local.HotMoviesStorage&#10;import tv.trakt.trakt.core.movies.sections.hot.usecase.GetHotMoviesUseCase&#10;import tv.trakt.trakt.core.movies.sections.popular.MoviesPopularViewModel&#10;import tv.trakt.trakt.core.movies.sections.popular.data.local.PopularMoviesLocalDataSource&#10;import tv.trakt.trakt.core.movies.sections.popular.data.local.PopularMoviesStorage&#10;import tv.trakt.trakt.core.movies.sections.popular.usecase.GetPopularMoviesUseCase&#10;import tv.trakt.trakt.core.movies.sections.recommended.MoviesRecommendedViewModel&#10;import tv.trakt.trakt.core.movies.sections.recommended.usecase.GetRecommendedMoviesUseCase&#10;import tv.trakt.trakt.core.movies.sections.trending.MoviesTrendingViewModel&#10;import tv.trakt.trakt.core.movies.sections.trending.usecase.GetTrendingMoviesUseCase&#10;&#10;internal val moviesDataModule = module {&#10;&#10;    single&lt;MoviesRemoteDataSource&gt; {&#10;        MoviesApiClient(&#10;            moviesApi = MoviesApi(&#10;                baseUrl = API_BASE_URL,&#10;                httpClientEngine = get(),&#10;                httpClientConfig = get(named(&quot;clientConfig&quot;)),&#10;            ),&#10;            recommendationsApi = RecommendationsApi(&#10;                baseUrl = API_BASE_URL,&#10;                httpClientEngine = get(),&#10;                httpClientConfig = get(named(&quot;authorizedClientConfig&quot;)),&#10;            ),&#10;        )&#10;    }&#10;&#10;    single&lt;PopularMoviesLocalDataSource&gt; {&#10;        PopularMoviesStorage()&#10;    }&#10;&#10;    single&lt;HotMoviesLocalDataSource&gt; {&#10;        HotMoviesStorage()&#10;    }&#10;&#10;    single&lt;AnticipatedMoviesLocalDataSource&gt; {&#10;        AnticipatedMoviesStorage()&#10;    }&#10;}&#10;&#10;internal val moviesModule = module {&#10;    factory {&#10;        GetTrendingMoviesUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetHotMoviesUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetPopularMoviesUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetAnticipatedMoviesUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetRecommendedMoviesUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        MoviesViewModel(&#10;            sessionManager = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        MoviesTrendingViewModel(&#10;            getTrendingUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        MoviesHotViewModel(&#10;            getHotUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        MoviesAnticipatedViewModel(&#10;            getAnticipatedUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        MoviesRecommendedViewModel(&#10;            getRecommendedUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        MoviesPopularViewModel(&#10;            getPopularUseCase = get(),&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/anticipated/MoviesAnticipatedViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/anticipated/MoviesAnticipatedViewModel.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.movies.sections.anticipated&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.movies.sections.anticipated.usecase.GetAnticipatedMoviesUseCase&#10;&#10;internal class MoviesAnticipatedViewModel(&#10;    private val getAnticipatedUseCase: GetAnticipatedMoviesUseCase,&#10;) : ViewModel() {&#10;    private val initialState = MoviesAnticipatedState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            val loadingJob = launch {&#10;                delay(250)&#10;                loadingState.update { LOADING }&#10;            }&#10;            try {&#10;                val localMovies = getAnticipatedUseCase.getLocalMovies()&#10;                if (localMovies.isNotEmpty()) {&#10;                    loadingJob.cancel()&#10;                    loadingState.update { DONE }&#10;                    itemsState.update { localMovies }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getAnticipatedUseCase.getMovies()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingJob.cancel()&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;MoviesAnticipatedState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        MoviesAnticipatedState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.anticipated&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.movies.sections.anticipated.usecase.GetAnticipatedMoviesUseCase&#10;&#10;internal class MoviesAnticipatedViewModel(&#10;    private val getAnticipatedUseCase: GetAnticipatedMoviesUseCase,&#10;) : ViewModel() {&#10;    private val initialState = MoviesAnticipatedState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val localMovies = getAnticipatedUseCase.getLocalMovies()&#10;                if (localMovies.isNotEmpty()) {&#10;                    itemsState.update { localMovies }&#10;                } else {&#10;                    loadingState.update { LOADING }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getAnticipatedUseCase.getAnticipatedMovies()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;MoviesAnticipatedState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        MoviesAnticipatedState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/anticipated/data/local/AnticipatedMoviesLocalDataSource.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/anticipated/data/local/AnticipatedMoviesLocalDataSource.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.anticipated.data.local&#10;&#10;import tv.trakt.trakt.core.movies.model.WatchersMovie&#10;import java.time.Instant&#10;&#10;internal interface AnticipatedMoviesLocalDataSource {&#10;    suspend fun addMovies(&#10;        movies: List&lt;WatchersMovie&gt;,&#10;        addedAt: Instant = Instant.now(),&#10;    )&#10;&#10;    suspend fun getMovies(): List&lt;WatchersMovie&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/anticipated/data/local/AnticipatedMoviesStorage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/anticipated/data/local/AnticipatedMoviesStorage.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.anticipated.data.local&#10;&#10;import kotlinx.coroutines.sync.Mutex&#10;import kotlinx.coroutines.sync.withLock&#10;import tv.trakt.trakt.common.model.TraktId&#10;import tv.trakt.trakt.core.movies.model.WatchersMovie&#10;import java.time.Instant&#10;&#10;internal class AnticipatedMoviesStorage : AnticipatedMoviesLocalDataSource {&#10;    private val mutex = Mutex()&#10;    private val moviesCache = mutableMapOf&lt;TraktId, WatchersMovie&gt;()&#10;&#10;    override suspend fun addMovies(&#10;        movies: List&lt;WatchersMovie&gt;,&#10;        addedAt: Instant,&#10;    ) {&#10;        mutex.withLock {&#10;            with(moviesCache) {&#10;                clear()&#10;                putAll(movies.associateBy { it.movie.ids.trakt })&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun getMovies(): List&lt;WatchersMovie&gt; {&#10;        return mutex.withLock {&#10;            moviesCache.values.toList()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/anticipated/usecase/GetAnticipatedMoviesUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/anticipated/usecase/GetAnticipatedMoviesUseCase.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.movies.sections.anticipated.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Movie&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.movies.data.remote.MoviesRemoteDataSource&#10;import tv.trakt.trakt.core.movies.model.WatchersMovie&#10;&#10;internal class GetAnticipatedMoviesUseCase(&#10;    private val remoteSource: MoviesRemoteDataSource,&#10;) {&#10;    suspend fun getAnticipatedMovies(): ImmutableList&lt;WatchersMovie&gt; {&#10;        return remoteSource.getAnticipated(20)&#10;            .asyncMap {&#10;                WatchersMovie(&#10;                    watchers = it.listCount,&#10;                    movie = Movie.fromDto(it.movie),&#10;                )&#10;            }&#10;            .toImmutableList()&#10;            .also { movies -&gt;&#10;//                localSource.upsertMovies(movies.map { it.movie })&#10;            }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.anticipated.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Movie&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.movies.data.remote.MoviesRemoteDataSource&#10;import tv.trakt.trakt.core.movies.model.WatchersMovie&#10;import tv.trakt.trakt.core.movies.sections.anticipated.data.local.AnticipatedMoviesLocalDataSource&#10;import java.time.Instant&#10;&#10;internal class GetAnticipatedMoviesUseCase(&#10;    private val remoteSource: MoviesRemoteDataSource,&#10;    private val localAnticipatedSource: AnticipatedMoviesLocalDataSource,&#10;) {&#10;    suspend fun getLocalMovies(): ImmutableList&lt;WatchersMovie&gt; {&#10;        return localAnticipatedSource.getMovies()&#10;            .sortedByDescending { it.watchers }&#10;            .toImmutableList()&#10;    }&#10;&#10;    suspend fun getAnticipatedMovies(): ImmutableList&lt;WatchersMovie&gt; {&#10;        return remoteSource.getAnticipated(20)&#10;            .asyncMap {&#10;                WatchersMovie(&#10;                    watchers = it.listCount,&#10;                    movie = Movie.fromDto(it.movie),&#10;                )&#10;            }&#10;            .toImmutableList()&#10;            .also { movies -&gt;&#10;                localAnticipatedSource.addMovies(&#10;                    movies = movies,&#10;                    addedAt = Instant.now(),&#10;                )&#10;            }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/hot/MoviesHotViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/hot/MoviesHotViewModel.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.movies.sections.hot&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.movies.sections.hot.usecase.GetHotMoviesUseCase&#10;&#10;internal class MoviesHotViewModel(&#10;    private val getHotUseCase: GetHotMoviesUseCase,&#10;) : ViewModel() {&#10;    private val initialState = MoviesHotState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            val loadingJob = launch {&#10;                delay(250)&#10;                loadingState.update { LOADING }&#10;            }&#10;            try {&#10;                val localMovies = getHotUseCase.getLocalMovies()&#10;                if (localMovies.isNotEmpty()) {&#10;                    loadingJob.cancel()&#10;                    loadingState.update { DONE }&#10;                    itemsState.update { localMovies }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getHotUseCase.getMovies()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingJob.cancel()&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;MoviesHotState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        MoviesHotState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.hot&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.movies.sections.hot.usecase.GetHotMoviesUseCase&#10;&#10;internal class MoviesHotViewModel(&#10;    private val getHotUseCase: GetHotMoviesUseCase,&#10;) : ViewModel() {&#10;    private val initialState = MoviesHotState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val localMovies = getHotUseCase.getLocalMovies()&#10;                if (localMovies.isNotEmpty()) {&#10;                    itemsState.update { localMovies }&#10;                } else {&#10;                    loadingState.update { LOADING }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getHotUseCase.getHotMovies()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;MoviesHotState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        MoviesHotState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/hot/data/local/HotMoviesLocalDataSource.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/hot/data/local/HotMoviesLocalDataSource.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.hot.data.local&#10;&#10;import tv.trakt.trakt.core.movies.model.WatchersMovie&#10;import java.time.Instant&#10;&#10;internal interface HotMoviesLocalDataSource {&#10;    suspend fun addMovies(&#10;        movies: List&lt;WatchersMovie&gt;,&#10;        addedAt: Instant = Instant.now(),&#10;    )&#10;&#10;    suspend fun getMovies(): List&lt;WatchersMovie&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/hot/data/local/HotMoviesStorage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/hot/data/local/HotMoviesStorage.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.hot.data.local&#10;&#10;import kotlinx.coroutines.sync.Mutex&#10;import kotlinx.coroutines.sync.withLock&#10;import tv.trakt.trakt.common.model.TraktId&#10;import tv.trakt.trakt.core.movies.model.WatchersMovie&#10;import java.time.Instant&#10;&#10;internal class HotMoviesStorage : HotMoviesLocalDataSource {&#10;    private val mutex = Mutex()&#10;    private val moviesCache = mutableMapOf&lt;TraktId, WatchersMovie&gt;()&#10;&#10;    override suspend fun addMovies(&#10;        movies: List&lt;WatchersMovie&gt;,&#10;        addedAt: Instant,&#10;    ) {&#10;        mutex.withLock {&#10;            with(moviesCache) {&#10;                clear()&#10;                putAll(movies.associateBy { it.movie.ids.trakt })&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun getMovies(): List&lt;WatchersMovie&gt; {&#10;        return mutex.withLock {&#10;            moviesCache.values.toList()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/hot/usecase/GetHotMoviesUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/hot/usecase/GetHotMoviesUseCase.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.movies.sections.hot.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Movie&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.movies.data.remote.MoviesRemoteDataSource&#10;import tv.trakt.trakt.core.movies.model.WatchersMovie&#10;&#10;internal class GetHotMoviesUseCase(&#10;    private val remoteSource: MoviesRemoteDataSource,&#10;) {&#10;    suspend fun getHotMovies(): ImmutableList&lt;WatchersMovie&gt; {&#10;        return remoteSource.getHot(20)&#10;            .asyncMap {&#10;                WatchersMovie(&#10;                    watchers = it.watchers,&#10;                    movie = Movie.fromDto(it.movie),&#10;                )&#10;            }&#10;            .toImmutableList()&#10;            .also { movies -&gt;&#10;//                localSource.upsertMovies(movies.map { it.movie })&#10;            }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.hot.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Movie&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.movies.data.remote.MoviesRemoteDataSource&#10;import tv.trakt.trakt.core.movies.model.WatchersMovie&#10;import tv.trakt.trakt.core.movies.sections.hot.data.local.HotMoviesLocalDataSource&#10;import java.time.Instant&#10;&#10;internal class GetHotMoviesUseCase(&#10;    private val remoteSource: MoviesRemoteDataSource,&#10;    private val localHotSource: HotMoviesLocalDataSource,&#10;) {&#10;    suspend fun getLocalMovies(): ImmutableList&lt;WatchersMovie&gt; {&#10;        return localHotSource.getMovies()&#10;            .sortedByDescending { it.watchers }&#10;            .toImmutableList()&#10;    }&#10;&#10;    suspend fun getHotMovies(): ImmutableList&lt;WatchersMovie&gt; {&#10;        return remoteSource.getHot(20)&#10;            .asyncMap {&#10;                WatchersMovie(&#10;                    watchers = it.watchers,&#10;                    movie = Movie.fromDto(it.movie),&#10;                )&#10;            }&#10;            .toImmutableList()&#10;            .also { movies -&gt;&#10;                localHotSource.addMovies(&#10;                    movies = movies,&#10;                    addedAt = Instant.now(),&#10;                )&#10;            }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/popular/MoviesPopularViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/popular/MoviesPopularViewModel.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.movies.sections.popular&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.movies.sections.popular.usecase.GetPopularMoviesUseCase&#10;&#10;internal class MoviesPopularViewModel(&#10;    private val getPopularUseCase: GetPopularMoviesUseCase,&#10;) : ViewModel() {&#10;    private val initialState = MoviesPopularState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            val loadingJob = launch {&#10;                delay(250)&#10;                loadingState.update { LOADING }&#10;            }&#10;            try {&#10;                val localMovies = getPopularUseCase.getLocalMovies()&#10;                if (localMovies.isNotEmpty()) {&#10;                    loadingJob.cancel()&#10;                    loadingState.update { DONE }&#10;                    itemsState.update { localMovies }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getPopularUseCase.getMovies()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingJob.cancel()&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;MoviesPopularState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        MoviesPopularState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.popular&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.movies.sections.popular.usecase.GetPopularMoviesUseCase&#10;&#10;internal class MoviesPopularViewModel(&#10;    private val getPopularUseCase: GetPopularMoviesUseCase,&#10;) : ViewModel() {&#10;    private val initialState = MoviesPopularState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val localMovies = getPopularUseCase.getLocalMovies()&#10;                if (localMovies.isNotEmpty()) {&#10;                    itemsState.update { localMovies }&#10;                } else {&#10;                    loadingState.update { LOADING }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getPopularUseCase.getPopularMovies()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;MoviesPopularState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        MoviesPopularState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/popular/data/local/PopularMoviesLocalDataSource.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/popular/data/local/PopularMoviesLocalDataSource.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.popular.data.local&#10;&#10;import tv.trakt.trakt.common.model.Movie&#10;import java.time.Instant&#10;&#10;internal interface PopularMoviesLocalDataSource {&#10;    suspend fun addMovies(&#10;        movies: List&lt;Movie&gt;,&#10;        addedAt: Instant = Instant.now(),&#10;    )&#10;&#10;    suspend fun getMovies(): List&lt;Movie&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/popular/data/local/PopularMoviesStorage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/popular/data/local/PopularMoviesStorage.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.popular.data.local&#10;&#10;import kotlinx.coroutines.sync.Mutex&#10;import kotlinx.coroutines.sync.withLock&#10;import tv.trakt.trakt.common.model.Movie&#10;import tv.trakt.trakt.common.model.TraktId&#10;import java.time.Instant&#10;&#10;internal class PopularMoviesStorage : PopularMoviesLocalDataSource {&#10;    private val mutex = Mutex()&#10;    private val moviesCache = mutableMapOf&lt;TraktId, Movie&gt;()&#10;&#10;    override suspend fun addMovies(&#10;        movies: List&lt;Movie&gt;,&#10;        addedAt: Instant,&#10;    ) {&#10;        mutex.withLock {&#10;            with(moviesCache) {&#10;                clear()&#10;                putAll(movies.associateBy { it.ids.trakt })&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun getMovies(): List&lt;Movie&gt; {&#10;        return mutex.withLock {&#10;            moviesCache.values.toList()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/popular/usecase/GetPopularMoviesUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/popular/usecase/GetPopularMoviesUseCase.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.movies.sections.popular.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Movie&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.movies.data.remote.MoviesRemoteDataSource&#10;&#10;internal class GetPopularMoviesUseCase(&#10;    private val remoteSource: MoviesRemoteDataSource,&#10;) {&#10;    suspend fun getPopularMovies(): ImmutableList&lt;Movie&gt; {&#10;        return remoteSource.getPopular(20)&#10;            .asyncMap {&#10;                Movie.fromDto(it)&#10;            }&#10;            .toImmutableList()&#10;            .also {&#10;//                localSource.upsertMovies(it)&#10;            }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.popular.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Movie&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.movies.data.remote.MoviesRemoteDataSource&#10;import tv.trakt.trakt.core.movies.sections.popular.data.local.PopularMoviesLocalDataSource&#10;import java.time.Instant&#10;&#10;internal class GetPopularMoviesUseCase(&#10;    private val remoteSource: MoviesRemoteDataSource,&#10;    private val localPopularSource: PopularMoviesLocalDataSource,&#10;) {&#10;    suspend fun getLocalMovies(): ImmutableList&lt;Movie&gt; {&#10;        return localPopularSource.getMovies()&#10;            .toImmutableList()&#10;    }&#10;&#10;    suspend fun getPopularMovies(): ImmutableList&lt;Movie&gt; {&#10;        return remoteSource.getPopular(20)&#10;            .asyncMap {&#10;                Movie.fromDto(it)&#10;            }&#10;            .toImmutableList()&#10;            .also { movies -&gt;&#10;                localPopularSource.addMovies(&#10;                    movies = movies,&#10;                    addedAt = Instant.now(),&#10;                )&#10;            }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/recommended/MoviesRecommendedViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/recommended/MoviesRecommendedViewModel.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.movies.sections.recommended&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.movies.sections.recommended.usecase.GetRecommendedMoviesUseCase&#10;&#10;internal class MoviesRecommendedViewModel(&#10;    private val getRecommendedUseCase: GetRecommendedMoviesUseCase,&#10;) : ViewModel() {&#10;    private val initialState = MoviesRecommendedState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            val loadingJob = launch {&#10;                delay(250)&#10;                loadingState.update { LOADING }&#10;            }&#10;            try {&#10;                val localMovies = getRecommendedUseCase.getLocalMovies()&#10;                if (localMovies.isNotEmpty()) {&#10;                    loadingJob.cancel()&#10;                    loadingState.update { DONE }&#10;                    itemsState.update { localMovies }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getRecommendedUseCase.getMovies()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load recommended movies&quot;)&#10;                }&#10;            } finally {&#10;                loadingJob.cancel()&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;MoviesRecommendedState&gt; = combine(&#10;        itemsState,&#10;        loadingState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        MoviesRecommendedState(&#10;            items = s1,&#10;            loading = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.recommended&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.movies.sections.recommended.usecase.GetRecommendedMoviesUseCase&#10;&#10;internal class MoviesRecommendedViewModel(&#10;    private val getRecommendedUseCase: GetRecommendedMoviesUseCase,&#10;) : ViewModel() {&#10;    private val initialState = MoviesRecommendedState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val localMovies = getRecommendedUseCase.getLocalMovies()&#10;                if (localMovies.isNotEmpty()) {&#10;                    itemsState.update { localMovies }&#10;                } else {&#10;                    loadingState.update { LOADING }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getRecommendedUseCase.getRecommendedMovies()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;MoviesRecommendedState&gt; = combine(&#10;        itemsState,&#10;        loadingState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        MoviesRecommendedState(&#10;            items = s1,&#10;            loading = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/recommended/data/local/RecommendedMoviesLocalDataSource.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/recommended/data/local/RecommendedMoviesLocalDataSource.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.recommended.data.local&#10;&#10;import tv.trakt.trakt.common.model.Movie&#10;import java.time.Instant&#10;&#10;internal interface RecommendedMoviesLocalDataSource {&#10;    suspend fun addMovies(&#10;        movies: List&lt;Movie&gt;,&#10;        addedAt: Instant = Instant.now(),&#10;    )&#10;&#10;    suspend fun getMovies(): List&lt;Movie&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/recommended/data/local/RecommendedMoviesStorage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/recommended/data/local/RecommendedMoviesStorage.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.recommended.data.local&#10;&#10;import kotlinx.coroutines.sync.Mutex&#10;import kotlinx.coroutines.sync.withLock&#10;import tv.trakt.trakt.common.model.Movie&#10;import tv.trakt.trakt.common.model.TraktId&#10;import java.time.Instant&#10;&#10;internal class RecommendedMoviesStorage : RecommendedMoviesLocalDataSource {&#10;    private val mutex = Mutex()&#10;    private val moviesCache = mutableMapOf&lt;TraktId, Movie&gt;()&#10;&#10;    override suspend fun addMovies(&#10;        movies: List&lt;Movie&gt;,&#10;        addedAt: Instant,&#10;    ) {&#10;        mutex.withLock {&#10;            with(moviesCache) {&#10;                clear()&#10;                putAll(movies.associateBy { it.ids.trakt })&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun getMovies(): List&lt;Movie&gt; {&#10;        return mutex.withLock {&#10;            moviesCache.values.toList()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/recommended/usecase/GetRecommendedMoviesUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/recommended/usecase/GetRecommendedMoviesUseCase.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.movies.sections.recommended.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Movie&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.movies.data.remote.MoviesRemoteDataSource&#10;&#10;internal class GetRecommendedMoviesUseCase(&#10;    private val remoteSource: MoviesRemoteDataSource,&#10;) {&#10;    suspend fun getRecommendedMovies(): ImmutableList&lt;Movie&gt; {&#10;        return remoteSource.getRecommended(20)&#10;            .asyncMap {&#10;                Movie.fromDto(it)&#10;            }&#10;            .toImmutableList()&#10;            .also { movies -&gt;&#10;//                localSource.upsertMovies(movies.map { it.movie })&#10;            }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.recommended.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Movie&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.movies.data.remote.MoviesRemoteDataSource&#10;import tv.trakt.trakt.core.movies.sections.recommended.data.local.RecommendedMoviesLocalDataSource&#10;import java.time.Instant&#10;&#10;internal class GetRecommendedMoviesUseCase(&#10;    private val remoteSource: MoviesRemoteDataSource,&#10;    private val localRecommendedSource: RecommendedMoviesLocalDataSource,&#10;) {&#10;    suspend fun getLocalMovies(): ImmutableList&lt;Movie&gt; {&#10;        return localRecommendedSource.getMovies()&#10;            .toImmutableList()&#10;    }&#10;&#10;    suspend fun getRecommendedMovies(): ImmutableList&lt;Movie&gt; {&#10;        return remoteSource.getRecommended(20)&#10;            .asyncMap {&#10;                Movie.fromDto(it)&#10;            }&#10;            .toImmutableList()&#10;            .also { movies -&gt;&#10;                localRecommendedSource.addMovies(&#10;                    movies = movies,&#10;                    addedAt = Instant.now(),&#10;                )&#10;            }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/trending/MoviesTrendingViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/trending/MoviesTrendingViewModel.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.movies.sections.trending&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.movies.sections.trending.usecase.GetTrendingMoviesUseCase&#10;&#10;internal class MoviesTrendingViewModel(&#10;    private val getTrendingUseCase: GetTrendingMoviesUseCase,&#10;) : ViewModel() {&#10;    private val initialState = MoviesTrendingState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            val loadingJob = launch {&#10;                delay(250)&#10;                loadingState.update { LOADING }&#10;            }&#10;            try {&#10;                val localMovies = getTrendingUseCase.getLocalMovies()&#10;                if (localMovies.isNotEmpty()) {&#10;                    loadingJob.cancel()&#10;                    loadingState.update { DONE }&#10;                    itemsState.update { localMovies }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getTrendingUseCase.getMovies()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingJob.cancel()&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;MoviesTrendingState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        MoviesTrendingState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.trending&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.movies.sections.trending.usecase.GetTrendingMoviesUseCase&#10;&#10;internal class MoviesTrendingViewModel(&#10;    private val getTrendingUseCase: GetTrendingMoviesUseCase,&#10;) : ViewModel() {&#10;    private val initialState = MoviesTrendingState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val localMovies = getTrendingUseCase.getLocalMovies()&#10;                if (localMovies.isNotEmpty()) {&#10;                    itemsState.update { localMovies }&#10;                } else {&#10;                    loadingState.update { LOADING }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getTrendingUseCase.getTrendingMovies()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;MoviesTrendingState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        MoviesTrendingState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/trending/data/local/TrendingMoviesLocalDataSource.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/trending/data/local/TrendingMoviesLocalDataSource.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.trending.data.local&#10;&#10;import tv.trakt.trakt.core.movies.model.WatchersMovie&#10;import java.time.Instant&#10;&#10;internal interface TrendingMoviesLocalDataSource {&#10;    suspend fun addMovies(&#10;        movies: List&lt;WatchersMovie&gt;,&#10;        addedAt: Instant = Instant.now(),&#10;    )&#10;&#10;    suspend fun getMovies(): List&lt;WatchersMovie&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/trending/data/local/TrendingMoviesStorage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/trending/data/local/TrendingMoviesStorage.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.trending.data.local&#10;&#10;import kotlinx.coroutines.sync.Mutex&#10;import kotlinx.coroutines.sync.withLock&#10;import tv.trakt.trakt.common.model.TraktId&#10;import tv.trakt.trakt.core.movies.model.WatchersMovie&#10;import java.time.Instant&#10;&#10;internal class TrendingMoviesStorage : TrendingMoviesLocalDataSource {&#10;    private val mutex = Mutex()&#10;    private val moviesCache = mutableMapOf&lt;TraktId, WatchersMovie&gt;()&#10;&#10;    override suspend fun addMovies(&#10;        movies: List&lt;WatchersMovie&gt;,&#10;        addedAt: Instant,&#10;    ) {&#10;        mutex.withLock {&#10;            with(moviesCache) {&#10;                clear()&#10;                putAll(movies.associateBy { it.movie.ids.trakt })&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun getMovies(): List&lt;WatchersMovie&gt; {&#10;        return mutex.withLock {&#10;            moviesCache.values.toList()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/trending/usecase/GetTrendingMoviesUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/movies/sections/trending/usecase/GetTrendingMoviesUseCase.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.movies.sections.trending.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Movie&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.movies.data.remote.MoviesRemoteDataSource&#10;import tv.trakt.trakt.core.movies.model.WatchersMovie&#10;&#10;internal class GetTrendingMoviesUseCase(&#10;    private val remoteSource: MoviesRemoteDataSource,&#10;) {&#10;    suspend fun getTrendingMovies(): ImmutableList&lt;WatchersMovie&gt; {&#10;        return remoteSource.getTrending(20)&#10;            .asyncMap {&#10;                WatchersMovie(&#10;                    watchers = it.watchers,&#10;                    movie = Movie.fromDto(it.movie),&#10;                )&#10;            }&#10;            .toImmutableList()&#10;            .also { movies -&gt;&#10;//                localSource.upsertMovies(movies.map { it.movie })&#10;            }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.movies.sections.trending.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Movie&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.movies.data.remote.MoviesRemoteDataSource&#10;import tv.trakt.trakt.core.movies.model.WatchersMovie&#10;import tv.trakt.trakt.core.movies.sections.trending.data.local.TrendingMoviesLocalDataSource&#10;import java.time.Instant&#10;&#10;internal class GetTrendingMoviesUseCase(&#10;    private val remoteSource: MoviesRemoteDataSource,&#10;    private val localTrendingSource: TrendingMoviesLocalDataSource,&#10;) {&#10;    suspend fun getLocalMovies(): ImmutableList&lt;WatchersMovie&gt; {&#10;        return localTrendingSource.getMovies()&#10;            .sortedByDescending { it.watchers }&#10;            .toImmutableList()&#10;    }&#10;&#10;    suspend fun getTrendingMovies(): ImmutableList&lt;WatchersMovie&gt; {&#10;        return remoteSource.getTrending(20)&#10;            .asyncMap {&#10;                WatchersMovie(&#10;                    watchers = it.watchers,&#10;                    movie = Movie.fromDto(it.movie),&#10;                )&#10;            }&#10;            .toImmutableList()&#10;            .also { movies -&gt;&#10;                localTrendingSource.addMovies(&#10;                    movies = movies,&#10;                    addedAt = Instant.now(),&#10;                )&#10;            }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/di/ShowsModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/di/ShowsModule.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.shows.di&#10;&#10;import org.koin.core.module.dsl.viewModel&#10;import org.koin.core.qualifier.named&#10;import org.koin.dsl.module&#10;import org.openapitools.client.apis.RecommendationsApi&#10;import org.openapitools.client.apis.ShowsApi&#10;import tv.trakt.trakt.common.Config.API_BASE_URL&#10;import tv.trakt.trakt.core.shows.ShowsViewModel&#10;import tv.trakt.trakt.core.shows.data.remote.ShowsApiClient&#10;import tv.trakt.trakt.core.shows.data.remote.ShowsRemoteDataSource&#10;import tv.trakt.trakt.core.shows.sections.anticipated.ShowsAnticipatedViewModel&#10;import tv.trakt.trakt.core.shows.sections.anticipated.usecase.GetAnticipatedShowsUseCase&#10;import tv.trakt.trakt.core.shows.sections.hot.ShowsHotViewModel&#10;import tv.trakt.trakt.core.shows.sections.hot.usecase.GetHotShowsUseCase&#10;import tv.trakt.trakt.core.shows.sections.popular.ShowsPopularViewModel&#10;import tv.trakt.trakt.core.shows.sections.popular.usecase.GetPopularShowsUseCase&#10;import tv.trakt.trakt.core.shows.sections.recommended.ShowsRecommendedViewModel&#10;import tv.trakt.trakt.core.shows.sections.recommended.data.local.RecommendedShowsLocalDataSource&#10;import tv.trakt.trakt.core.shows.sections.recommended.data.local.RecommendedShowsStorage&#10;import tv.trakt.trakt.core.shows.sections.recommended.usecase.GetRecommendedShowsUseCase&#10;import tv.trakt.trakt.core.shows.sections.trending.ShowsTrendingViewModel&#10;import tv.trakt.trakt.core.shows.sections.trending.data.local.TrendingShowsLocalDataSource&#10;import tv.trakt.trakt.core.shows.sections.trending.data.local.TrendingShowsStorage&#10;import tv.trakt.trakt.core.shows.sections.trending.usecase.GetTrendingShowsUseCase&#10;&#10;internal val showsDataModule = module {&#10;&#10;    single&lt;ShowsRemoteDataSource&gt; {&#10;        ShowsApiClient(&#10;            showsApi = ShowsApi(&#10;                baseUrl = API_BASE_URL,&#10;                httpClientEngine = get(),&#10;                httpClientConfig = get(named(&quot;clientConfig&quot;)),&#10;            ),&#10;            recommendationsApi = RecommendationsApi(&#10;                baseUrl = API_BASE_URL,&#10;                httpClientEngine = get(),&#10;                httpClientConfig = get(named(&quot;authorizedClientConfig&quot;)),&#10;            ),&#10;        )&#10;    }&#10;&#10;    single&lt;TrendingShowsLocalDataSource&gt; {&#10;        TrendingShowsStorage()&#10;    }&#10;&#10;    single&lt;RecommendedShowsLocalDataSource&gt; {&#10;        RecommendedShowsStorage()&#10;    }&#10;}&#10;&#10;internal val showsModule = module {&#10;    factory {&#10;        GetTrendingShowsUseCase(&#10;            remoteSource = get(),&#10;            localTrendingSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetHotShowsUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetPopularShowsUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetAnticipatedShowsUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetRecommendedShowsUseCase(&#10;            remoteSource = get(),&#10;            localRecommendedSource = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        ShowsViewModel(&#10;            sessionManager = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        ShowsTrendingViewModel(&#10;            getTrendingUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        ShowsHotViewModel(&#10;            getHotUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        ShowsAnticipatedViewModel(&#10;            getAnticipatedUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        ShowsRecommendedViewModel(&#10;            getRecommendedUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        ShowsPopularViewModel(&#10;            getPopularUseCase = get(),&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.di&#10;&#10;import org.koin.core.module.dsl.viewModel&#10;import org.koin.core.qualifier.named&#10;import org.koin.dsl.module&#10;import org.openapitools.client.apis.RecommendationsApi&#10;import org.openapitools.client.apis.ShowsApi&#10;import tv.trakt.trakt.common.Config.API_BASE_URL&#10;import tv.trakt.trakt.core.shows.ShowsViewModel&#10;import tv.trakt.trakt.core.shows.data.remote.ShowsApiClient&#10;import tv.trakt.trakt.core.shows.data.remote.ShowsRemoteDataSource&#10;import tv.trakt.trakt.core.shows.sections.anticipated.ShowsAnticipatedViewModel&#10;import tv.trakt.trakt.core.shows.sections.anticipated.usecase.GetAnticipatedShowsUseCase&#10;import tv.trakt.trakt.core.shows.sections.hot.ShowsHotViewModel&#10;import tv.trakt.trakt.core.shows.sections.hot.usecase.GetHotShowsUseCase&#10;import tv.trakt.trakt.core.shows.sections.popular.ShowsPopularViewModel&#10;import tv.trakt.trakt.core.shows.sections.popular.usecase.GetPopularShowsUseCase&#10;import tv.trakt.trakt.core.shows.sections.recommended.ShowsRecommendedViewModel&#10;import tv.trakt.trakt.core.shows.sections.recommended.data.local.RecommendedShowsLocalDataSource&#10;import tv.trakt.trakt.core.shows.sections.recommended.data.local.RecommendedShowsStorage&#10;import tv.trakt.trakt.core.shows.sections.recommended.usecase.GetRecommendedShowsUseCase&#10;import tv.trakt.trakt.core.shows.sections.trending.ShowsTrendingViewModel&#10;import tv.trakt.trakt.core.shows.sections.trending.data.local.TrendingShowsLocalDataSource&#10;import tv.trakt.trakt.core.shows.sections.trending.data.local.TrendingShowsStorage&#10;import tv.trakt.trakt.core.shows.sections.trending.usecase.GetTrendingShowsUseCase&#10;&#10;internal val showsDataModule = module {&#10;&#10;    single&lt;ShowsRemoteDataSource&gt; {&#10;        ShowsApiClient(&#10;            showsApi = ShowsApi(&#10;                baseUrl = API_BASE_URL,&#10;                httpClientEngine = get(),&#10;                httpClientConfig = get(named(&quot;clientConfig&quot;)),&#10;            ),&#10;            recommendationsApi = RecommendationsApi(&#10;                baseUrl = API_BASE_URL,&#10;                httpClientEngine = get(),&#10;                httpClientConfig = get(named(&quot;authorizedClientConfig&quot;)),&#10;            ),&#10;        )&#10;    }&#10;&#10;    single&lt;TrendingShowsLocalDataSource&gt; {&#10;        TrendingShowsStorage()&#10;    }&#10;&#10;    single&lt;RecommendedShowsLocalDataSource&gt; {&#10;        RecommendedShowsStorage()&#10;    }&#10;&#10;    single&lt;PopularShowsLocalDataSource&gt; {&#10;        PopularShowsStorage()&#10;    }&#10;&#10;    single&lt;HotShowsLocalDataSource&gt; {&#10;        HotShowsStorage()&#10;    }&#10;&#10;    single&lt;AnticipatedShowsLocalDataSource&gt; {&#10;        AnticipatedShowsStorage()&#10;    }&#10;}&#10;&#10;internal val showsModule = module {&#10;    factory {&#10;        GetTrendingShowsUseCase(&#10;            remoteSource = get(),&#10;            localTrendingSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetHotShowsUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetPopularShowsUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetAnticipatedShowsUseCase(&#10;            remoteSource = get(),&#10;        )&#10;    }&#10;&#10;    factory {&#10;        GetRecommendedShowsUseCase(&#10;            remoteSource = get(),&#10;            localRecommendedSource = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        ShowsViewModel(&#10;            sessionManager = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        ShowsTrendingViewModel(&#10;            getTrendingUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        ShowsHotViewModel(&#10;            getHotUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        ShowsAnticipatedViewModel(&#10;            getAnticipatedUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        ShowsRecommendedViewModel(&#10;            getRecommendedUseCase = get(),&#10;        )&#10;    }&#10;&#10;    viewModel {&#10;        ShowsPopularViewModel(&#10;            getPopularUseCase = get(),&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/anticipated/ShowsAnticipatedViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/anticipated/ShowsAnticipatedViewModel.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.shows.sections.anticipated&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.shows.sections.anticipated.usecase.GetAnticipatedShowsUseCase&#10;&#10;internal class ShowsAnticipatedViewModel(&#10;    private val getAnticipatedUseCase: GetAnticipatedShowsUseCase,&#10;) : ViewModel() {&#10;    private val initialState = ShowsAnticipatedState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            val loadingJob = launch {&#10;                delay(250)&#10;                loadingState.update { LOADING }&#10;            }&#10;            try {&#10;                val localShows = getAnticipatedUseCase.getLocalShows()&#10;                if (localShows.isNotEmpty()) {&#10;                    loadingJob.cancel()&#10;                    loadingState.update { DONE }&#10;                    itemsState.update { localShows }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getAnticipatedUseCase.getShows()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingJob.cancel()&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;ShowsAnticipatedState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        ShowsAnticipatedState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.sections.anticipated&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.shows.sections.anticipated.usecase.GetAnticipatedShowsUseCase&#10;&#10;internal class ShowsAnticipatedViewModel(&#10;    private val getAnticipatedUseCase: GetAnticipatedShowsUseCase,&#10;) : ViewModel() {&#10;    private val initialState = ShowsAnticipatedState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val localShows = getAnticipatedUseCase.getLocalShows()&#10;                if (localShows.isNotEmpty()) {&#10;                    itemsState.update { localShows }&#10;                } else {&#10;                    loadingState.update { LOADING }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getAnticipatedUseCase.getAnticipatedShows()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;ShowsAnticipatedState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        ShowsAnticipatedState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/anticipated/data/local/AnticipatedShowsLocalDataSource.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/anticipated/data/local/AnticipatedShowsLocalDataSource.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.sections.anticipated.data.local&#10;&#10;import tv.trakt.trakt.core.shows.model.WatchersShow&#10;import java.time.Instant&#10;&#10;internal interface AnticipatedShowsLocalDataSource {&#10;    suspend fun addShows(&#10;        shows: List&lt;WatchersShow&gt;,&#10;        addedAt: Instant = Instant.now(),&#10;    )&#10;&#10;    suspend fun getShows(): List&lt;WatchersShow&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/anticipated/data/local/AnticipatedShowsStorage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/anticipated/data/local/AnticipatedShowsStorage.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.sections.anticipated.data.local&#10;&#10;import kotlinx.coroutines.sync.Mutex&#10;import kotlinx.coroutines.sync.withLock&#10;import tv.trakt.trakt.common.model.TraktId&#10;import tv.trakt.trakt.core.shows.model.WatchersShow&#10;import java.time.Instant&#10;&#10;internal class AnticipatedShowsStorage : AnticipatedShowsLocalDataSource {&#10;    private val mutex = Mutex()&#10;    private val showsCache = mutableMapOf&lt;TraktId, WatchersShow&gt;()&#10;&#10;    override suspend fun addShows(&#10;        shows: List&lt;WatchersShow&gt;,&#10;        addedAt: Instant,&#10;    ) {&#10;        mutex.withLock {&#10;            with(showsCache) {&#10;                clear()&#10;                putAll(shows.associateBy { it.show.ids.trakt })&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun getShows(): List&lt;WatchersShow&gt; {&#10;        return mutex.withLock {&#10;            showsCache.values.toList()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/anticipated/usecase/GetAnticipatedShowsUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/anticipated/usecase/GetAnticipatedShowsUseCase.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.shows.sections.anticipated.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Show&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.shows.data.remote.ShowsRemoteDataSource&#10;import tv.trakt.trakt.core.shows.model.WatchersShow&#10;&#10;internal class GetAnticipatedShowsUseCase(&#10;    private val remoteSource: ShowsRemoteDataSource,&#10;) {&#10;    suspend fun getAnticipatedShows(): ImmutableList&lt;WatchersShow&gt; {&#10;        return remoteSource.getAnticipated(20)&#10;            .asyncMap {&#10;                WatchersShow(&#10;                    watchers = it.listCount,&#10;                    show = Show.fromDto(it.show),&#10;                )&#10;            }&#10;            .toImmutableList()&#10;            .also { shows -&gt;&#10;//                localSource.upsertShows(shows.map { it.show })&#10;            }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.sections.anticipated.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Show&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.shows.data.remote.ShowsRemoteDataSource&#10;import tv.trakt.trakt.core.shows.model.WatchersShow&#10;import tv.trakt.trakt.core.shows.sections.anticipated.data.local.AnticipatedShowsLocalDataSource&#10;import java.time.Instant&#10;&#10;internal class GetAnticipatedShowsUseCase(&#10;    private val remoteSource: ShowsRemoteDataSource,&#10;    private val localAnticipatedSource: AnticipatedShowsLocalDataSource,&#10;) {&#10;    suspend fun getLocalShows(): ImmutableList&lt;WatchersShow&gt; {&#10;        return localAnticipatedSource.getShows()&#10;            .sortedByDescending { it.watchers }&#10;            .toImmutableList()&#10;    }&#10;&#10;    suspend fun getAnticipatedShows(): ImmutableList&lt;WatchersShow&gt; {&#10;        return remoteSource.getAnticipated(20)&#10;            .asyncMap {&#10;                WatchersShow(&#10;                    watchers = it.listCount,&#10;                    show = Show.fromDto(it.show),&#10;                )&#10;            }&#10;            .toImmutableList()&#10;            .also { shows -&gt;&#10;                localAnticipatedSource.addShows(&#10;                    shows = shows,&#10;                    addedAt = Instant.now(),&#10;                )&#10;            }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/hot/ShowsHotViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/hot/ShowsHotViewModel.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.shows.sections.hot&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.shows.sections.hot.usecase.GetHotShowsUseCase&#10;&#10;internal class ShowsHotViewModel(&#10;    private val getHotUseCase: GetHotShowsUseCase,&#10;) : ViewModel() {&#10;    private val initialState = ShowsHotState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            val loadingJob = launch {&#10;                delay(250)&#10;                loadingState.update { LOADING }&#10;            }&#10;            try {&#10;                val localShows = getHotUseCase.getLocalShows()&#10;                if (localShows.isNotEmpty()) {&#10;                    loadingJob.cancel()&#10;                    loadingState.update { DONE }&#10;                    itemsState.update { localShows }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getHotUseCase.getShows()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingJob.cancel()&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;ShowsHotState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        ShowsHotState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.sections.hot&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.shows.sections.hot.usecase.GetHotShowsUseCase&#10;&#10;internal class ShowsHotViewModel(&#10;    private val getHotUseCase: GetHotShowsUseCase,&#10;) : ViewModel() {&#10;    private val initialState = ShowsHotState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val localShows = getHotUseCase.getLocalShows()&#10;                if (localShows.isNotEmpty()) {&#10;                    itemsState.update { localShows }&#10;                } else {&#10;                    loadingState.update { LOADING }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getHotUseCase.getHotShows()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;ShowsHotState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        ShowsHotState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/hot/data/local/HotShowsLocalDataSource.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/hot/data/local/HotShowsLocalDataSource.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.sections.hot.data.local&#10;&#10;import tv.trakt.trakt.core.shows.model.WatchersShow&#10;import java.time.Instant&#10;&#10;internal interface HotShowsLocalDataSource {&#10;    suspend fun addShows(&#10;        shows: List&lt;WatchersShow&gt;,&#10;        addedAt: Instant = Instant.now(),&#10;    )&#10;&#10;    suspend fun getShows(): List&lt;WatchersShow&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/hot/data/local/HotShowsStorage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/hot/data/local/HotShowsStorage.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.sections.hot.data.local&#10;&#10;import kotlinx.coroutines.sync.Mutex&#10;import kotlinx.coroutines.sync.withLock&#10;import tv.trakt.trakt.common.model.TraktId&#10;import tv.trakt.trakt.core.shows.model.WatchersShow&#10;import java.time.Instant&#10;&#10;internal class HotShowsStorage : HotShowsLocalDataSource {&#10;    private val mutex = Mutex()&#10;    private val showsCache = mutableMapOf&lt;TraktId, WatchersShow&gt;()&#10;&#10;    override suspend fun addShows(&#10;        shows: List&lt;WatchersShow&gt;,&#10;        addedAt: Instant,&#10;    ) {&#10;        mutex.withLock {&#10;            with(showsCache) {&#10;                clear()&#10;                putAll(shows.associateBy { it.show.ids.trakt })&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun getShows(): List&lt;WatchersShow&gt; {&#10;        return mutex.withLock {&#10;            showsCache.values.toList()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/hot/usecase/GetHotShowsUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/hot/usecase/GetHotShowsUseCase.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.shows.sections.hot.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Show&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.shows.data.remote.ShowsRemoteDataSource&#10;import tv.trakt.trakt.core.shows.model.WatchersShow&#10;&#10;internal class GetHotShowsUseCase(&#10;    private val remoteSource: ShowsRemoteDataSource,&#10;) {&#10;    suspend fun getHotShows(): ImmutableList&lt;WatchersShow&gt; {&#10;        return remoteSource.getHot(20)&#10;            .asyncMap {&#10;                WatchersShow(&#10;                    watchers = it.watchers,&#10;                    show = Show.fromDto(it.show),&#10;                )&#10;            }&#10;            .toImmutableList()&#10;            .also { shows -&gt;&#10;//                localSource.upsertShows(shows.map { it.show })&#10;            }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.sections.hot.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.model.Show&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.shows.data.remote.ShowsRemoteDataSource&#10;import tv.trakt.trakt.core.shows.model.WatchersShow&#10;import tv.trakt.trakt.core.shows.sections.hot.data.local.HotShowsLocalDataSource&#10;import java.time.Instant&#10;&#10;internal class GetHotShowsUseCase(&#10;    private val remoteSource: ShowsRemoteDataSource,&#10;    private val localHotSource: HotShowsLocalDataSource,&#10;) {&#10;    suspend fun getLocalShows(): ImmutableList&lt;WatchersShow&gt; {&#10;        return localHotSource.getShows()&#10;            .sortedByDescending { it.watchers }&#10;            .toImmutableList()&#10;    }&#10;&#10;    suspend fun getHotShows(): ImmutableList&lt;WatchersShow&gt; {&#10;        return remoteSource.getHot(20)&#10;            .asyncMap {&#10;                WatchersShow(&#10;                    watchers = it.watchers,&#10;                    show = Show.fromDto(it.show),&#10;                )&#10;            }&#10;            .toImmutableList()&#10;            .also { shows -&gt;&#10;                localHotSource.addShows(&#10;                    shows = shows,&#10;                    addedAt = Instant.now(),&#10;                )&#10;            }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/popular/ShowsPopularViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/popular/ShowsPopularViewModel.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.shows.sections.popular&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.shows.sections.popular.usecase.GetPopularShowsUseCase&#10;&#10;internal class ShowsPopularViewModel(&#10;    private val getPopularUseCase: GetPopularShowsUseCase,&#10;) : ViewModel() {&#10;    private val initialState = ShowsPopularState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            val loadingJob = launch {&#10;                delay(250)&#10;                loadingState.update { LOADING }&#10;            }&#10;            try {&#10;                val localShows = getPopularUseCase.getLocalShows()&#10;                if (localShows.isNotEmpty()) {&#10;                    loadingJob.cancel()&#10;                    loadingState.update { DONE }&#10;                    itemsState.update { localShows }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getPopularUseCase.getShows()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingJob.cancel()&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;ShowsPopularState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        ShowsPopularState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.sections.popular&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.shows.sections.popular.usecase.GetPopularShowsUseCase&#10;&#10;internal class ShowsPopularViewModel(&#10;    private val getPopularUseCase: GetPopularShowsUseCase,&#10;) : ViewModel() {&#10;    private val initialState = ShowsPopularState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val localShows = getPopularUseCase.getLocalShows()&#10;                if (localShows.isNotEmpty()) {&#10;                    itemsState.update { localShows }&#10;                } else {&#10;                    loadingState.update { LOADING }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getPopularUseCase.getPopularShows()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;ShowsPopularState&gt; = combine(&#10;        loadingState,&#10;        itemsState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        ShowsPopularState(&#10;            loading = s1,&#10;            items = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/popular/data/local/PopularShowsLocalDataSource.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/popular/data/local/PopularShowsLocalDataSource.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.sections.popular.data.local&#10;&#10;import tv.trakt.trakt.common.model.Show&#10;import java.time.Instant&#10;&#10;internal interface PopularShowsLocalDataSource {&#10;    suspend fun addShows(&#10;        shows: List&lt;Show&gt;,&#10;        addedAt: Instant = Instant.now(),&#10;    )&#10;&#10;    suspend fun getShows(): List&lt;Show&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/popular/data/local/PopularShowsStorage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/popular/data/local/PopularShowsStorage.kt" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.sections.popular.data.local&#10;&#10;import kotlinx.coroutines.sync.Mutex&#10;import kotlinx.coroutines.sync.withLock&#10;import tv.trakt.trakt.common.model.Show&#10;import tv.trakt.trakt.common.model.TraktId&#10;import java.time.Instant&#10;&#10;internal class PopularShowsStorage : PopularShowsLocalDataSource {&#10;    private val mutex = Mutex()&#10;    private val showsCache = mutableMapOf&lt;TraktId, Show&gt;()&#10;&#10;    override suspend fun addShows(&#10;        shows: List&lt;Show&gt;,&#10;        addedAt: Instant,&#10;    ) {&#10;        mutex.withLock {&#10;            with(showsCache) {&#10;                clear()&#10;                putAll(shows.associateBy { it.ids.trakt })&#10;            }&#10;        }&#10;    }&#10;&#10;    override suspend fun getShows(): List&lt;Show&gt; {&#10;        return mutex.withLock {&#10;            showsCache.values.toList()&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/popular/usecase/GetPopularShowsUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/popular/usecase/GetPopularShowsUseCase.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.shows.sections.popular.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Show&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.shows.data.remote.ShowsRemoteDataSource&#10;&#10;internal class GetPopularShowsUseCase(&#10;    private val remoteSource: ShowsRemoteDataSource,&#10;) {&#10;    suspend fun getPopularShows(): ImmutableList&lt;Show&gt; {&#10;        return remoteSource.getPopular(20)&#10;            .asyncMap {&#10;                Show.fromDto(it)&#10;            }&#10;            .toImmutableList()&#10;            .also {&#10;//                localSource.upsertShows(it)&#10;            }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.sections.popular.usecase&#10;&#10;import kotlinx.collections.immutable.ImmutableList&#10;import kotlinx.collections.immutable.toImmutableList&#10;import tv.trakt.trakt.common.helpers.extensions.asyncMap&#10;import tv.trakt.trakt.common.model.Show&#10;import tv.trakt.trakt.common.model.fromDto&#10;import tv.trakt.trakt.core.shows.data.remote.ShowsRemoteDataSource&#10;import tv.trakt.trakt.core.shows.sections.popular.data.local.PopularShowsLocalDataSource&#10;import java.time.Instant&#10;&#10;internal class GetPopularShowsUseCase(&#10;    private val remoteSource: ShowsRemoteDataSource,&#10;    private val localPopularSource: PopularShowsLocalDataSource,&#10;) {&#10;    suspend fun getLocalShows(): ImmutableList&lt;Show&gt; {&#10;        return localPopularSource.getShows()&#10;            .toImmutableList()&#10;    }&#10;&#10;    suspend fun getPopularShows(): ImmutableList&lt;Show&gt; {&#10;        return remoteSource.getPopular(20)&#10;            .asyncMap {&#10;                Show.fromDto(it)&#10;            }&#10;            .toImmutableList()&#10;            .also { shows -&gt;&#10;                localPopularSource.addShows(&#10;                    shows = shows,&#10;                    addedAt = Instant.now(),&#10;                )&#10;            }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/recommended/ShowsRecommendedViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/trakt/trakt/core/shows/sections/recommended/ShowsRecommendedViewModel.kt" />
              <option name="originalContent" value="package tv.trakt.trakt.core.shows.sections.recommended&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.shows.sections.recommended.usecase.GetRecommendedShowsUseCase&#10;&#10;internal class ShowsRecommendedViewModel(&#10;    private val getRecommendedUseCase: GetRecommendedShowsUseCase,&#10;) : ViewModel() {&#10;    private val initialState = ShowsRecommendedState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            val loadingJob = launch {&#10;                delay(250)&#10;                loadingState.update { LOADING }&#10;            }&#10;            try {&#10;                val localShows = getRecommendedUseCase.getLocalShows()&#10;                if (localShows.isNotEmpty()) {&#10;                    loadingJob.cancel()&#10;                    loadingState.update { DONE }&#10;                    itemsState.update { localShows }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getRecommendedUseCase.getShows()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load recommended shows&quot;)&#10;                }&#10;            } finally {&#10;                loadingJob.cancel()&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;ShowsRecommendedState&gt; = combine(&#10;        itemsState,&#10;        loadingState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        ShowsRecommendedState(&#10;            items = s1,&#10;            loading = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package tv.trakt.trakt.core.shows.sections.recommended&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.SharingStarted&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.combine&#10;import kotlinx.coroutines.flow.stateIn&#10;import kotlinx.coroutines.flow.update&#10;import kotlinx.coroutines.launch&#10;import timber.log.Timber&#10;import tv.trakt.trakt.common.helpers.LoadingState.DONE&#10;import tv.trakt.trakt.common.helpers.LoadingState.LOADING&#10;import tv.trakt.trakt.common.helpers.extensions.rethrowCancellation&#10;import tv.trakt.trakt.core.shows.sections.recommended.usecase.GetRecommendedShowsUseCase&#10;&#10;internal class ShowsRecommendedViewModel(&#10;    private val getRecommendedUseCase: GetRecommendedShowsUseCase,&#10;) : ViewModel() {&#10;    private val initialState = ShowsRecommendedState()&#10;&#10;    private val itemsState = MutableStateFlow(initialState.items)&#10;    private val loadingState = MutableStateFlow(initialState.loading)&#10;    private val errorState = MutableStateFlow(initialState.error)&#10;&#10;    init {&#10;        loadData()&#10;    }&#10;&#10;    private fun loadData() {&#10;        viewModelScope.launch {&#10;            try {&#10;                val localShows = getRecommendedUseCase.getLocalShows()&#10;                if (localShows.isNotEmpty()) {&#10;                    itemsState.update { localShows }&#10;                } else {&#10;                    loadingState.update { LOADING }&#10;                }&#10;&#10;                itemsState.update {&#10;                    getRecommendedUseCase.getRecommendedShows()&#10;                }&#10;            } catch (error: Exception) {&#10;                error.rethrowCancellation {&#10;                    errorState.update { error }&#10;                    Timber.e(error, &quot;Failed to load data&quot;)&#10;                }&#10;            } finally {&#10;                loadingState.update { DONE }&#10;            }&#10;        }&#10;    }&#10;&#10;    val state: StateFlow&lt;ShowsRecommendedState&gt; = combine(&#10;        itemsState,&#10;        loadingState,&#10;        errorState,&#10;    ) { s1, s2, s3 -&gt;&#10;        ShowsRecommendedState(&#10;            items = s1,&#10;            loading = s2,&#10;            error = s3,&#10;        )&#10;    }.stateIn(&#10;        scope = viewModelScope,&#10;        started = SharingStarted.WhileSubscribed(5_000),&#10;        initialValue = initialState,&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tv/src/main/java/tv/trakt/trakt/app/core/home/sections/recommended/HomeRecommendedViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tv/src/main/java/tv/trakt/trakt/app/core/home/sections/recommended/HomeRecommendedViewModel.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tv/src/main/java/tv/trakt/trakt/app/core/home/sections/recommended/usecases/GetRecommendedUseCase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tv/src/main/java/tv/trakt/trakt/app/core/home/sections/recommended/usecases/GetRecommendedUseCase.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>